# Implementation Guide: Add Invalid Pattern Rules to EDN Lexer

## Objective
Modify the `erldn_lexer.xrl` file to add strict validation rules that catch invalid numeric patterns as errors, preventing the lexer from incorrectly tokenizing them as separate valid tokens.

## Background
Currently, the lexer is too permissive with invalid numeric formats. For example:
- `0xGG` tokenizes as `[0, {symbol,xGG}]` instead of producing an error
- `0899` tokenizes as `[0, 899]` instead of producing an error  
- `22//7` tokenizes as `[22, {symbol,'/'}, {symbol,'/'}, 7]` instead of producing an error
- `089` tokenizes as `[0, 89]` instead of `[0, 8, 9]`

This happens because the lexer operates on the longest-match principle and falls back to shorter valid tokens when a pattern doesn't fully match.

## Implementation Steps

### 1. Add Invalid Pattern Definitions

In the `Definitions` section of `erldn_lexer.xrl`, add these new pattern definitions:

```erlang
% Invalid numeric patterns that must be caught as errors
InvalidHex = 0[xX]([0-9a-fA-F]*[g-zG-Z]+[0-9a-zA-Z]*|[^0-9a-fA-F\s\[\]\{\}\(\),;]+)
InvalidOctal = 0[0-7]*[89]+[0-9]*
InvalidRational = [+-]?[0-9]+//+[0-9]*
InvalidRadix = [+-]?([0-9]+[rR][^0-9a-zA-Z\s\[\]\{\}\(\),;]+|[0-9]+[rR][0-9a-zA-Z]*[^0-9a-zA-Z\s\[\]\{\}\(\),;]+)
InvalidNumeric = [+-]?[0-9]+[a-zA-Z]+[0-9a-zA-Z]*
```

### 2. Add Invalid Pattern Rules

In the `Rules` section, add these rules **BEFORE** all valid number rules (hexadecimal, octal, radix, rational, etc.):

```erlang
% These patterns are needed due to the fact that, without them, the lexer is too 
% permissive and falls back to tokenizing invalid numeric formats as separate tokens. 
% The fundamental issue is that **the lexer operates on longest-match principle** - 
% it will always try to match the longest possible token. When a pattern doesn't 
% fully match, the lexer backtracks and matches shorter valid tokens.
{InvalidHex}      : {error, {invalid_hexadecimal, TokenLine, TokenChars}}.
{InvalidOctal}    : {error, {invalid_octal, TokenLine, TokenChars}}.
{InvalidRational} : {error, {invalid_rational, TokenLine, TokenChars}}.
{InvalidRadix}    : {error, {invalid_radix, TokenLine, TokenChars}}.
{InvalidNumeric}  : {error, {invalid_numeric, TokenLine, TokenChars}}.
```

### 3. Pattern Explanations

#### InvalidHex Pattern
```
0[xX]([0-9a-fA-F]*[g-zG-Z]+[0-9a-zA-Z]*|[^0-9a-fA-F\s\[\]\{\}\(\),;]+)
```
- Matches `0x` or `0X` followed by:
  - Valid hex digits followed by invalid hex letters (g-z, G-Z) and any alphanumeric
  - OR any sequence that's not valid hex digits or delimiters
- Examples caught: `0xGG`, `0xFFG`, `0x12Z9`

#### InvalidOctal Pattern
```
0[0-7]*[89]+[0-9]*
```
- Matches `0` followed by valid octal digits, then digits 8 or 9, then any digits
- Examples caught: `0899`, `0778`, `089`, `08`, `09`

#### InvalidRational Pattern
```
[+-]?[0-9]+//+[0-9]*
```
- Matches numbers with double (or more) slashes
- Examples caught: `22//7`, `1///2`, `5//`

#### InvalidRadix Pattern
```
[+-]?([0-9]+[rR][^0-9a-zA-Z\s\[\]\{\}\(\),;]+|[0-9]+[rR][0-9a-zA-Z]*[^0-9a-zA-Z\s\[\]\{\}\(\),;]+)
```
- Matches radix notation with invalid characters after the `r` or `R`
- Examples caught: `2r@`, `16r!FF`, `8r9`

#### InvalidNumeric Pattern
```
[+-]?[0-9]+[a-zA-Z]+[0-9a-zA-Z]*
```
- Matches numbers immediately followed by letters (without valid prefix like 0x)
- Examples caught: `123abc`, `42foo`
- Note: This should NOT match valid patterns like `0xFF`, `2r10`, or `123N`

### 4. Rule Ordering

The rules must appear in this order in the `Rules` section:

```erlang
Rules.

% Invalid patterns MUST come first to take precedence
{InvalidHex}      : {error, {invalid_hexadecimal, TokenLine, TokenChars}}.
{InvalidOctal}    : {error, {invalid_octal, TokenLine, TokenChars}}.
{InvalidRational} : {error, {invalid_rational, TokenLine, TokenChars}}.
{InvalidRadix}    : {error, {invalid_radix, TokenLine, TokenChars}}.
{InvalidNumeric}  : {error, {invalid_numeric, TokenLine, TokenChars}}.

% Then the valid numeric patterns
{Hexadecimal}     : make_token(hexadecimal, TokenLine, TokenChars, fun parse_hexadecimal/1).
{Octal}           : make_token(octal, TokenLine, TokenChars, fun parse_octal/1).
{Zero}            : make_token(integer, TokenLine, TokenChars, fun parse_zero/1).
{Radix}           : make_token(radix, TokenLine, TokenChars, fun parse_radix/1).
{Rational}        : make_token(rational, TokenLine, TokenChars, fun parse_rational/1).
% ... rest of rules
```

### 5. Update Error Handling

Modify the `erldn.erl` file's `lex_str/1` function to properly handle the new error format:

```erlang
lex_str(Str) -> 
    case erldn_lexer:string(Str) of
        {ok, Tokens, Line} -> 
            {ok, Tokens, Line};
        {error, {ErrorType, Line, Chars}, _} ->
            {error, {ErrorType, Line, Chars}};
        {error, {ErrorType, Line, Chars}} ->
            {error, {ErrorType, Line, Chars}};
        Error -> 
            Error
    end.
```

### 6. Test Cases

Create test cases to verify the invalid patterns are caught:

```erlang
% Test invalid hexadecimal
invalid_hex_test() ->
    ?assertMatch({error, {invalid_hexadecimal, _, "0xGG"}}, erldn:lex_str("0xGG")),
    ?assertMatch({error, {invalid_hexadecimal, _, "0xFFG"}}, erldn:lex_str("0xFFG")),
    ?assertMatch({error, {invalid_hexadecimal, _, "0x12Z9"}}, erldn:lex_str("0x12Z9")).

% Test invalid octal
invalid_octal_test() ->
    ?assertMatch({error, {invalid_octal, _, "0899"}}, erldn:lex_str("0899")),
    ?assertMatch({error, {invalid_octal, _, "089"}}, erldn:lex_str("089")),
    ?assertMatch({error, {invalid_octal, _, "08"}}, erldn:lex_str("08")),
    ?assertMatch({error, {invalid_octal, _, "09"}}, erldn:lex_str("09")).

% Test invalid rational
invalid_rational_test() ->
    ?assertMatch({error, {invalid_rational, _, "22//7"}}, erldn:lex_str("22//7")),
    ?assertMatch({error, {invalid_rational, _, "1///2"}}, erldn:lex_str("1///2")).

% Test invalid radix
invalid_radix_test() ->
    ?assertMatch({error, {invalid_radix, _, "2r123"}}, erldn:lex_str("2r123")),
    ?assertMatch({error, {invalid_radix, _, "37rABC"}}, erldn:lex_str("37rABC")).

% Test valid patterns still work
valid_patterns_test() ->
    ?assertMatch({ok, [{hexadecimal, _, 255}], _}, erldn:lex_str("0xFF")),
    ?assertMatch({ok, [{octal, _, 511}], _}, erldn:lex_str("0777")),
    ?assertMatch({ok, [{rational, _, {rational, 22, 7}}], _}, erldn:lex_str("22/7")),
    ?assertMatch({ok, [{radix, _, 10}], _}, erldn:lex_str("2r1010")).
```

## Important Notes

1. **Pattern Order**: Invalid patterns MUST come before valid patterns in the Rules section. Lexer rules are processed in order, and the first matching rule wins.

2. **Error Format**: The error tuple format `{error, {error_type, line, chars}}` should be consistent across all invalid pattern rules.

3. **Delimiter Awareness**: The invalid patterns should be careful not to match across token boundaries. Use delimiter characters `\s\[\]\{\}\(\),;` in the patterns where appropriate.

4. **Precedence**: These rules will prevent the lexer from falling back to tokenizing invalid formats as separate tokens, ensuring strict validation at the lexical level.

5. **Testing**: Thoroughly test both invalid cases (should produce errors) and valid cases (should still work correctly) to ensure the new rules don't break existing functionality.

## Expected Behavior After Implementation

- `0xGG` → `{error, {invalid_hexadecimal, 1, "0xGG"}}`
- `0899` → `{error, {invalid_octal, 1, "0899"}}`
- `22//7` → `{error, {invalid_rational, 1, "22//7"}}`
- `089` → `{error, {invalid_octal, 1, "089"}}`
- `0xFF` → `{ok, [{hexadecimal, 1, 255}], 1}` (still works)
- `0777` → `{ok, [{octal, 1, 511}], 1}` (still works)
- `22/7` → `{ok, [{rational, 1, {rational, 22, 7}}], 1}` (still works)