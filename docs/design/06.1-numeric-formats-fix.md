# Amendment: Fix Rational Number Token Structure

## Overview

This amendment corrects an error in the rational number implementation from the main numeric formats guide. The original implementation created incorrectly nested rational structures. This document provides instructions to fix the token structure to be consistent with other numeric types.

## Problem Description

The original implementation produced double-wrapped rational tokens:

```erlang
% INCORRECT: Double-wrapped structure
{rational, 1, {rational, 22, 7}}  % Lexer token
{rational, 22, 7}                 % After unwrapping - still has redundant rational atom
```

## Correct Structure

The rational tokens should follow the same pattern as other numeric types:

```erlang
% CORRECT: Consistent with other numeric tokens
{rational, 1, {22, 7}}   % Lexer token - just the numerator/denominator tuple
{rational, 22, 7}        % Parser AST - wrapped with rational atom for type identification
```

This matches the pattern of other tokens like:
- `{integer, 1, 42}` → `42`
- `{float, 1, 3.14}` → `3.14` 
- `{rational, 1, {22, 7}}` → `{rational, 22, 7}`

## Required Changes

### 1. Update Lexer Function (`src/erldn_lexer.xrl`)

**Change the `parse_rational/1` function in the Erlang code section:**

```erlang
% OLD - INCORRECT (creates double-wrapped structure):
parse_rational(Str) ->
    {Sign, Rest} = extract_sign(Str),
    case re:split(Rest, "/", [{return, list}]) of
        [NumerStr, DenomStr] ->
            Numerator = list_to_integer(NumerStr),
            Denominator = list_to_integer(DenomStr),
            if 
                Denominator =/= 0 ->
                    {rational, Sign * Numerator, Denominator};  % ← PROBLEM: Extra rational atom
                true -> 
                    error({zero_denominator, Str})
            end;
        _ -> error({invalid_rational_format, Str})
    end.

% NEW - CORRECT (returns just the tuple):
parse_rational(Str) ->
    {Sign, Rest} = extract_sign(Str),
    case re:split(Rest, "/", [{return, list}]) of
        [NumerStr, DenomStr] ->
            Numerator = list_to_integer(NumerStr),
            Denominator = list_to_integer(DenomStr),
            if 
                Denominator =/= 0 ->
                    {Sign * Numerator, Denominator};  % ← FIXED: Just return the tuple
                true -> 
                    error({zero_denominator, Str})
            end;
        _ -> error({invalid_rational_format, Str})
    end.
```

### 2. Update Parser Rules (`src/erldn_parser.yrl`)

**Ensure the rational value rule wraps the tuple correctly:**

```erlang
% The parser rule should wrap the unwrapped tuple with the rational atom:
value -> rational : {rational, unwrap('$1')}.
```

**Note:** The `unwrap/1` function extracts `{22, 7}` from `{rational, 1, {22, 7}}`, then we wrap it as `{rational, {22, 7}}`. Wait, that's still wrong...

**Actually, the correct parser rule should be:**

```erlang
value -> rational : 
    {Numerator, Denominator} = unwrap('$1'),
    {rational, Numerator, Denominator}.
```

### 3. Update All Test Expectations

**Update lexer tests (`test/erldn_numeric_lexer_test.erl`):**

```erlang
% OLD - INCORRECT expectations:
rational_basic_test() -> 
    check_lex("22/7", {rational, 1, {rational, 22, 7}}).

rational_negative_test() -> 
    check_lex("-3/4", {rational, 1, {rational, -3, 4}}).

% NEW - CORRECT expectations:
rational_basic_test() -> 
    check_lex("22/7", {rational, 1, {22, 7}}).

rational_negative_test() -> 
    check_lex("-3/4", {rational, 1, {-3, 4}}).

rational_positive_test() -> 
    check_lex("+1/2", {rational, 1, {1, 2}}).
```

**Update parser tests (`test/erldn_numeric_parser_test.erl`):**

```erlang
% Parser tests should remain the same - they expect the final AST form:
rational_parse_test() ->
    check_parse("22/7", {rational, 22, 7}).

rational_negative_parse_test() ->
    check_parse("-3/4", {rational, -3, 4}).

rational_positive_parse_test() ->
    check_parse("+1/2", {rational, 1, 2}).
```

### 4. Update String Conversion Tests

**The string conversion tests should remain unchanged** since they test the final AST representation:

```erlang
% These remain correct:
rational_roundtrip_test() ->
    Input = "22/7",
    {ok, Parsed} = erldn:parse_str(Input),  % Parsed = {rational, 22, 7}
    Reconstructed = lists:flatten(erldn:to_string(Parsed)),
    ?assertEqual("22/7", Reconstructed).
```

### 5. Update Erlang Conversion Tests

**These should also remain unchanged** since they test the final AST:

```erlang
% These remain correct:
rational_to_erlang_test() ->
    {ok, Parsed} = erldn:parse_str("22/7"),  % Parsed = {rational, 22, 7}
    Result = erldn:to_erlang(Parsed),
    ?assertEqual({rational, 22, 7}, Result).
```

### 6. Update Error Handling Tests

**Update any tests that check lexer error conditions:**

```erlang
% If you had any lexer-level error tests that expected the old format,
% update them to expect the new tuple format in error messages
```

### 7. Update Documentation Examples

**Update any documentation that shows the lexer token structure:**

```markdown
<!-- OLD - INCORRECT -->
The lexer produces tokens like `{rational, 1, {rational, 22, 7}}` for the input `"22/7"`.

<!-- NEW - CORRECT -->
The lexer produces tokens like `{rational, 1, {22, 7}}` for the input `"22/7"`.
The parser then converts this to the AST representation `{rational, 22, 7}`.
```

### 8. Verification Steps

After making these changes, verify the fix works correctly:

#### 8.1 Test Lexer Output

```erlang
% In the Erlang shell or a test:
{ok, [Token], _} = erldn:lex_str("22/7").
% Should return: {rational, 1, {22, 7}}
% NOT: {rational, 1, {rational, 22, 7}}
```

#### 8.2 Test Parser Output

```erlang
% In the Erlang shell or a test:
{ok, AST} = erldn:parse_str("22/7").
% Should return: {rational, 22, 7}
% This is the correct final AST representation
```

#### 8.3 Test Round-trip Conversion

```erlang
% Verify round-trip still works:
{ok, Parsed} = erldn:parse_str("22/7"),
StringForm = lists:flatten(erldn:to_string(Parsed)),
{ok, ReParsed} = erldn:parse_str(StringForm),
?assertEqual(Parsed, ReParsed).
```

## Why This Structure is Correct

The corrected structure follows the established pattern:

1. **Lexer Level**: Produces raw token with parsed value
   - `{integer, 1, 42}` - integer value
   - `{float, 1, 3.14}` - float value  
   - `{rational, 1, {22, 7}}` - numerator/denominator tuple

2. **Parser Level**: Creates appropriate AST representation
   - `42` - unwrapped integer
   - `3.14` - unwrapped float
   - `{rational, 22, 7}` - wrapped rational for type identification

3. **String Conversion**: Uses AST representation
   - `42` → `"42"`
   - `3.14` → `"3.14"`
   - `{rational, 22, 7}` → `"22/7"`

## Testing the Fix

Run these specific tests to verify the fix:

```bash
# Test just the numeric lexer tests
rebar3 eunit --module=erldn_numeric_lexer_test

# Test the specific rational functions
rebar3 eunit --module=erldn_numeric_parser_test

# Verify round-trip conversion works
rebar3 eunit --module=erldn_numeric_string_test
```

## Summary of Changes

| Component | Change Required |
|-----------|-----------------|
| **Lexer Function** | Remove extra `rational` atom from return value |
| **Parser Rule** | Ensure proper wrapping of tuple as `{rational, N, D}` |
| **Lexer Tests** | Update expectations to `{rational, 1, {22, 7}}` |
| **Parser Tests** | Keep existing expectations (they're correct) |
| **String Tests** | Keep existing (they're correct) |
| **Erlang Tests** | Keep existing (they're correct) |
| **Documentation** | Update lexer token structure examples |

The key insight is that the lexer should return the minimal parsed representation, and the parser should add semantic wrapping for the AST. This keeps the implementation consistent with other numeric types and avoids confusing double-wrapped structures.